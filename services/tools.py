# services/tools.py - FIXED VERSION

import os
import json
from tavily import TavilyClient
import logging
import requests

logger = logging.getLogger(__name__)

def web_search(params: dict, api_key: str = None) -> str:
    """
    Performs a web search using the Tavily API to find up-to-date information.
    This function is automatically called by the AI when it needs current information.

    Args:
        params (dict): A dictionary containing the search parameters, generated by the AI. 
                       Expected to have a 'query' key.

    Returns:
        str: A formatted summary of the search results with actual content.
    """
    if not api_key:
        api_key = os.getenv("TAVILY_API_KEY")
    if not api_key:
        logger.error("Tavily API key not found.")
        return "Error: Tavily API key is not configured."

    try:
        query = params.get("query") if isinstance(params, dict) else params
        if not query:
            logger.warning("Web search called without a query.")
            return "Error: Search query was not provided."

        logger.info(f"üõ∞Ô∏è Performing Tavily web search for: '{query}'")
        tavily = TavilyClient(api_key=api_key)
        
        # FIXED: Use search_depth="advanced" for better content extraction
        # and include_raw_content=True to get actual content
        response = tavily.search(
            query=query, 
            search_depth="advanced",  # Changed from "basic" to "advanced"
            max_results=3,  # Reduced to 3 for better quality
            include_raw_content=True,  # NEW: Get actual content
            include_answer=True  # NEW: Get Tavily's AI-generated answer
        )
        
        results = response.get('results', [])
        answer = response.get('answer', '')  # NEW: AI-generated answer from Tavily
        
        logger.info(f"‚úÖ Tavily search returned {len(results)} results with content.")
        
        # FIXED: Format the results properly with content summaries
        formatted_results = []
        
        # Add Tavily's AI answer if available
        if answer:
            formatted_results.append(f"SUMMARY: {answer}")
        
        # Add content from each result
        for i, result in enumerate(results[:3], 1):  # Limit to top 3 results
            title = result.get('title', 'No title')
            url = result.get('url', '')
            content = result.get('content', '')  # This is the extracted content
            
            if content:
                # Truncate content to reasonable length
                content_snippet = content[:500] + "..." if len(content) > 500 else content
                formatted_results.append(f"SOURCE {i}: {title}\n{content_snippet}\nURL: {url}")
            else:
                formatted_results.append(f"SOURCE {i}: {title}\nURL: {url}")
        
        # Return formatted string instead of raw JSON
        final_result = "\n\n".join(formatted_results)
        logger.info(f"üéØ Returning formatted search results: {len(final_result)} characters")
        
        return final_result

    except Exception as e:
        logger.error(f"‚ùå Error during Tavily web search: {e}")
        return f"Error: An exception occurred during web search: {str(e)}"


def get_current_weather(params: dict, api_key: str = None) -> str:
    """
    Gets the current weather for a specified location using the OpenWeatherMap API.
    """
    if not api_key:
        api_key = os.getenv("OPENWEATHER_API_KEY")
    if not api_key:
        logger.error("OpenWeather API key not found.")
        return "Error: OpenWeather API key is not configured."

    location = params.get("location")
    if not location:
        logger.warning("Weather check called without a location.")
        return "Error: Location was not provided for the weather check."

    logger.info(f"üå¶Ô∏è Fetching weather for: '{location}'")
    
    try:
        url = f"http://api.openweathermap.org/data/2.5/weather?q={location}&appid={api_key}&units=metric"
        response = requests.get(url)
        response.raise_for_status()
        
        weather_data = response.json()
        
        if weather_data.get("cod") != 200:
             return f"Error: Could not retrieve weather for {location}. Reason: {weather_data.get('message', 'Unknown error')}"

        city = weather_data.get("name", "the specified location")
        country = weather_data.get("sys", {}).get("country", "")
        description = weather_data["weather"][0]["description"]
        temp = weather_data["main"]["temp"]
        feels_like = weather_data["main"]["feels_like"]
        humidity = weather_data["main"]["humidity"]
        wind_speed = weather_data.get("wind", {}).get("speed", 0)
        
        # Enhanced weather response
        formatted_response = f"""Current weather in {city}{', ' + country if country else ''}:
- Condition: {description.title()}
- Temperature: {int(temp)}¬∞C (feels like {int(feels_like)}¬∞C)
- Humidity: {humidity}%
- Wind Speed: {wind_speed} m/s"""
        
        logger.info(f"‚úÖ Weather response: '{formatted_response}'")
        return formatted_response

    except requests.exceptions.RequestException as e:
        logger.error(f"‚ùå Error during OpenWeather API call: {e}")
        return f"Error: An exception occurred while fetching weather data: {str(e)}"
    except Exception as e:
        logger.error(f"‚ùå An unexpected error occurred in get_current_weather: {e}")
        return "Error: An unexpected error occurred while processing the weather request."


# NEW: Additional tool for getting current time/date
def get_current_time(params: dict = None, api_key: str = None) -> str:
    """
    Gets the current date and time.
    This function is automatically called by the AI when the user asks about current time or date.
    """
    from datetime import datetime
    import pytz
    
    try:
        # Default to UTC, but you can modify this based on user location
        now = datetime.now(pytz.UTC)
        formatted_time = now.strftime("%A, %B %d, %Y at %H:%M:%S UTC")
        
        logger.info(f"üïê Current time requested: {formatted_time}")
        return f"Current date and time: {formatted_time}"
        
    except Exception as e:
        logger.error(f"‚ùå Error getting current time: {e}")
        return f"Error: Could not retrieve current time: {str(e)}"
    
# NEW: Tool to open a website
def open_website_function(params: dict, api_key: str = None) -> str:
    """
    Determines the correct URL for a given website name and returns a command to open it.
    This is called by the AI when asked to open a website like "Open Netflix" or "Launch Google".
    """
    website_name = params.get("website_name")
    if not isinstance(website_name, str) or not website_name.strip():
        logger.warning("Website open tool called without a name.")
        return "Error: Website name was not provided."

    # Normalize the name for lookup
    normalized_name = website_name.strip().lower().replace(" ", "")

    # Predefined dictionary for common sites
    common_websites = {
        "google": "https://www.google.com",
        "youtube": "https://www.youtube.com",
        "facebook": "https://www.facebook.com",
        "netflix": "https://www.netflix.com",
        "amazon": "https://www.amazon.com",
        "wikipedia": "https://www.wikipedia.org",
        "twitter": "https://www.twitter.com",
        "instagram": "https://www.instagram.com",
        "linkedin": "https://www.linkedin.com",
        "reddit": "https://www.reddit.com",
    }

    url = common_websites.get(normalized_name)

    # If not in the dictionary, construct a plausible URL
    if not url:
        if "." in normalized_name:
            url = f"https://{normalized_name}"
        else:
            url = f"https://www.{normalized_name}.com"
    
    logger.info(f"üñ•Ô∏è Website action requested for '{website_name}'. Resolved URL: {url}")
    
    # Return a special formatted string for the backend to parse.
    # This is more robust than just returning the URL.
    return f"ACTION_OPEN_URL::{url}"